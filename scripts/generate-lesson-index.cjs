/* eslint-env node */
/* eslint-disable @typescript-eslint/no-require-imports */

const fs = require("fs");
const path = require("path");

const lessonsDir = path.join(__dirname, "..", "src", "content", "lessons");
const outputPath = path.join(lessonsDir, "index.ts");

const header = `// Auto-generated by scripts/generate-lesson-index.cjs
// Do not edit manually.
import type { LessonMeta, LessonModule } from "@/features/lessons/model/types";

export const lessonLoaders: Record<string, Record<string, () => Promise<LessonModule>>> = {
`;

function collectMdxFiles(dir = ".") {
  const entries = [];
  const fullDir = path.join(lessonsDir, dir);

  for (const item of fs.readdirSync(fullDir, { withFileTypes: true })) {
    if (item.isDirectory()) {
      entries.push(...collectMdxFiles(path.join(dir, item.name)));
    } else if (item.isFile() && item.name.endsWith(".mdx")) {
      const relPath = path.join(dir, item.name);
      entries.push(relPath.replace(/^[.][/\\]?/, ""));
    }
  }

  return entries;
}

function build() {
  try {
    fs.mkdirSync(lessonsDir, { recursive: true });
  } catch {
    // ignore
  }

  const mdxFiles = collectMdxFiles();

  const lessons = mdxFiles.map((filePath) => {
    const baseName = path.basename(filePath);
    const match = baseName.match(/^(?<slug>.+?)(?:\.(?<locale>[a-z]{2}))?\.mdx$/i);
    const slug = match?.groups?.slug ?? baseName.replace(/\.mdx$/, "");
    const locale = match?.groups?.locale?.toLowerCase() || "en";
    const source = fs.readFileSync(path.join(lessonsDir, filePath), "utf8");
    const meta = extractMeta(source, slug);
    const segments = filePath.split(path.sep);
    const categoryFromPath = segments.length > 1 ? segments[0] : "general";
    const normalizedPath = filePath.split(path.sep).join("/");
    return { file: normalizedPath, slug, locale, meta, categoryFromPath };
  });

  const lessonLoadersObj = {};
  const lessonMetaByLocaleObj = {};
  const localeSet = new Set();

  for (const lesson of lessons) {
    if (!lessonLoadersObj[lesson.slug]) lessonLoadersObj[lesson.slug] = {};
    lessonLoadersObj[lesson.slug][lesson.locale] = `./${lesson.file}`;

    if (!lessonMetaByLocaleObj[lesson.slug]) lessonMetaByLocaleObj[lesson.slug] = {};
    const safeMeta = lesson.meta ?? {
      slug: lesson.slug,
      title: lesson.slug,
      description: "",
      order: 0,
      category: lesson.categoryFromPath,
    };
    lessonMetaByLocaleObj[lesson.slug][lesson.locale] = {
      ...safeMeta,
      slug: lesson.slug,
      category: safeMeta.category ?? lesson.categoryFromPath ?? "general",
    };

    localeSet.add(lesson.locale);
  }

  const entries = Object.entries(lessonLoadersObj)
    .map(([slug, locales]) => {
      const localeEntries = Object.entries(locales)
        .map(([locale, file]) => `    "${locale}": () => import("${file}"),`)
        .join("\n");
      return `  "${slug}": {\n${localeEntries}\n  },`;
    })
    .join("\n");

  const metaEntries = Object.entries(lessonMetaByLocaleObj)
    .map(([slug, locales]) => `  "${slug}": ${JSON.stringify(locales)},`)
    .join("\n");

  const footer = `};\n\nexport const lessonMetaByLocale: Record<string, Record<string, LessonMeta>> = {\n${metaEntries}\n};\n\nexport const lessonMeta: Record<string, LessonMeta> = Object.fromEntries(
  Object.entries(lessonMetaByLocale).map(([slug, metas]) => [slug, metas["en"] ?? Object.values(metas)[0]]),
);\n\nexport const lessonSlugs = Object.keys(lessonLoaders);\n\nexport const availableLocales = ${JSON.stringify(Array.from(localeSet))};\nexport const defaultLocale = "en";\n`;

  const content = `${header}${entries}\n${footer}`;
  fs.writeFileSync(outputPath, content);
}

function extractMeta(source, slug) {
  const match = source.match(/export\s+const\s+meta\s*=\s*({[\s\S]*?})\s*;/);
  if (!match) return null;

  try {
    const meta = new Function(`return (${match[1]});`)();
    if (!meta || typeof meta !== "object") return null;
    return {
      ...meta,
      slug: typeof meta.slug === "string" && meta.slug.trim() ? meta.slug : slug,
    };
  } catch (error) {
    console.warn(`Unable to parse meta for lesson "${slug}":`, error);
    return null;
  }
}

build();
